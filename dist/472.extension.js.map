{"version":3,"file":"472.extension.js","mappings":"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","sources":["webpack://scan2findimgs/./node_modules/jsonrepair/lib/esm/utils/JSONRepairError.js","webpack://scan2findimgs/./node_modules/jsonrepair/lib/esm/utils/stringUtils.js","webpack://scan2findimgs/./node_modules/jsonrepair/lib/esm/regular/jsonrepair.js"],"sourcesContent":["export class JSONRepairError extends Error {\n  constructor(message, position) {\n    super(message + ' at position ' + position);\n    this.position = position;\n  }\n}\n//# sourceMappingURL=JSONRepairError.js.map","export const codeBackslash = 0x5c; // \"\\\"\nexport const codeSlash = 0x2f; // \"/\"\nexport const codeAsterisk = 0x2a; // \"*\"\nexport const codeOpeningBrace = 0x7b; // \"{\"\nexport const codeClosingBrace = 0x7d; // \"}\"\nexport const codeOpeningBracket = 0x5b; // \"[\"\nexport const codeClosingBracket = 0x5d; // \"]\"\nexport const codeOpenParenthesis = 0x28; // \"(\"\nexport const codeCloseParenthesis = 0x29; // \")\"\nexport const codeSpace = 0x20; // \" \"\nexport const codeNewline = 0xa; // \"\\n\"\nexport const codeTab = 0x9; // \"\\t\"\nexport const codeReturn = 0xd; // \"\\r\"\nexport const codeBackspace = 0x08; // \"\\b\"\nexport const codeFormFeed = 0x0c; // \"\\f\"\nexport const codeDoubleQuote = 0x0022; // \"\nexport const codePlus = 0x2b; // \"+\"\nexport const codeMinus = 0x2d; // \"-\"\nexport const codeQuote = 0x27; // \"'\"\nexport const codeZero = 0x30; // \"0\"\nexport const codeNine = 0x39; // \"9\"\nexport const codeComma = 0x2c; // \",\"\nexport const codeDot = 0x2e; // \".\" (dot, period)\nexport const codeColon = 0x3a; // \":\"\nexport const codeSemicolon = 0x3b; // \";\"\nexport const codeUppercaseA = 0x41; // \"A\"\nexport const codeLowercaseA = 0x61; // \"a\"\nexport const codeUppercaseE = 0x45; // \"E\"\nexport const codeLowercaseE = 0x65; // \"e\"\nexport const codeUppercaseF = 0x46; // \"F\"\nexport const codeLowercaseF = 0x66; // \"f\"\nconst codeNonBreakingSpace = 0xa0;\nconst codeEnQuad = 0x2000;\nconst codeHairSpace = 0x200a;\nconst codeNarrowNoBreakSpace = 0x202f;\nconst codeMediumMathematicalSpace = 0x205f;\nconst codeIdeographicSpace = 0x3000;\nconst codeDoubleQuoteLeft = 0x201c; // “\nconst codeDoubleQuoteRight = 0x201d; // ”\nconst codeQuoteLeft = 0x2018; // ‘\nconst codeQuoteRight = 0x2019; // ’\nconst codeGraveAccent = 0x0060; // `\nconst codeAcuteAccent = 0x00b4; // ´\n\nexport function isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nexport function isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nexport function isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nexport function isDelimiter(char) {\n  return regexDelimiter.test(char);\n}\nconst regexDelimiter = /^[,:[\\]/{}()\\n+]$/;\nexport function isDelimiterExceptSlash(char) {\n  return isDelimiter(char) && char !== '/';\n}\nexport function isStartOfValue(char) {\n  return regexStartOfValue.test(char) || char && isQuote(char.charCodeAt(0));\n}\n\n// alpha, number, minus, or opening bracket or brace\nconst regexStartOfValue = /^[[{\\w-]$/;\nexport function isControlCharacter(code) {\n  return code === codeNewline || code === codeReturn || code === codeTab || code === codeBackspace || code === codeFormFeed;\n}\n\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n */\nexport function isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n */\nexport function isSpecialWhitespace(code) {\n  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n */\nexport function isQuote(code) {\n  // the first check double quotes, since that occurs most often\n  return isDoubleQuoteLike(code) || isSingleQuoteLike(code);\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n */\nexport function isDoubleQuoteLike(code) {\n  // the first check double quotes, since that occurs most often\n  return code === codeDoubleQuote || code === codeDoubleQuoteLeft || code === codeDoubleQuoteRight;\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Does NOT test for special variants of double quotes.\n */\nexport function isDoubleQuote(code) {\n  return code === codeDoubleQuote;\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n */\nexport function isSingleQuoteLike(code) {\n  return code === codeQuote || code === codeQuoteLeft || code === codeQuoteRight || code === codeGraveAccent || code === codeAcuteAccent;\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Does NOT test for special variants of single quotes.\n */\nexport function isSingleQuote(code) {\n  return code === codeQuote;\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n */\nexport function stripLastOccurrence(text, textToStrip) {\n  let stripRemainingText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const index = text.lastIndexOf(textToStrip);\n  return index !== -1 ? text.substring(0, index) + (stripRemainingText ? '' : text.substring(index + 1)) : text;\n}\nexport function insertBeforeLastWhitespace(text, textToInsert) {\n  let index = text.length;\n  if (!isWhitespace(text.charCodeAt(index - 1))) {\n    // no trailing whitespaces\n    return text + textToInsert;\n  }\n  while (isWhitespace(text.charCodeAt(index - 1))) {\n    index--;\n  }\n  return text.substring(0, index) + textToInsert + text.substring(index);\n}\nexport function removeAtIndex(text, start, count) {\n  return text.substring(0, start) + text.substring(start + count);\n}\n\n/**\n * Test whether a string ends with a newline or comma character and optional whitespace\n */\nexport function endsWithCommaOrNewline(text) {\n  return /[,\\n][ \\t\\r]*$/.test(text);\n}\nexport function isFunctionName(text) {\n  return /^\\w+$/.test(text);\n}\n//# sourceMappingURL=stringUtils.js.map","import { JSONRepairError } from '../utils/JSONRepairError.js';\nimport { codeAsterisk, codeBackslash, codeCloseParenthesis, codeClosingBrace, codeClosingBracket, codeColon, codeComma, codeDot, codeDoubleQuote, codeLowercaseE, codeMinus, codeNewline, codeOpeningBrace, codeOpeningBracket, codeOpenParenthesis, codePlus, codeSemicolon, codeSlash, codeUppercaseE, endsWithCommaOrNewline, insertBeforeLastWhitespace, isControlCharacter, isDelimiter, isDelimiterExceptSlash, isDigit, isDoubleQuote, isDoubleQuoteLike, isFunctionName, isHex, isQuote, isSingleQuote, isSingleQuoteLike, isSpecialWhitespace, isStartOfValue, isValidStringCharacter, isWhitespace, removeAtIndex, stripLastOccurrence } from '../utils/stringUtils.js';\nconst controlCharacters = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n};\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text) {\n  let i = 0; // current index in text\n  let output = ''; // generated output\n\n  const processed = parseValue();\n  if (!processed) {\n    throwUnexpectedEnd();\n  }\n  const processedComma = parseCharacter(codeComma);\n  if (processedComma) {\n    parseWhitespaceAndSkipComments();\n  }\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',');\n    }\n    parseNewlineDelimitedJSON();\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',');\n  }\n\n  // repair redundant end quotes\n  while (text.charCodeAt(i) === codeClosingBrace || text.charCodeAt(i) === codeClosingBracket) {\n    i++;\n    parseWhitespaceAndSkipComments();\n  }\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output;\n  }\n  throwUnexpectedCharacter();\n  function parseValue() {\n    parseWhitespaceAndSkipComments();\n    const processed = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString();\n    parseWhitespaceAndSkipComments();\n    return processed;\n  }\n  function parseWhitespaceAndSkipComments() {\n    const start = i;\n    let changed = parseWhitespace();\n    do {\n      changed = parseComment();\n      if (changed) {\n        changed = parseWhitespace();\n      }\n    } while (changed);\n    return i > start;\n  }\n  function parseWhitespace() {\n    let whitespace = '';\n    let normal;\n    while ((normal = isWhitespace(text.charCodeAt(i))) || isSpecialWhitespace(text.charCodeAt(i))) {\n      if (normal) {\n        whitespace += text[i];\n      } else {\n        // repair special whitespace\n        whitespace += ' ';\n      }\n      i++;\n    }\n    if (whitespace.length > 0) {\n      output += whitespace;\n      return true;\n    }\n    return false;\n  }\n  function parseComment() {\n    // find a block comment '/* ... */'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeAsterisk) {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++;\n      }\n      i += 2;\n      return true;\n    }\n\n    // find a line comment '// ...'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeSlash) {\n      // repair line comment by skipping it\n      while (i < text.length && text.charCodeAt(i) !== codeNewline) {\n        i++;\n      }\n      return true;\n    }\n    return false;\n  }\n  function parseCharacter(code) {\n    if (text.charCodeAt(i) === code) {\n      output += text[i];\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipCharacter(code) {\n    if (text.charCodeAt(i) === code) {\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipEscapeCharacter() {\n    return skipCharacter(codeBackslash);\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis() {\n    parseWhitespaceAndSkipComments();\n    if (text.charCodeAt(i) === codeDot && text.charCodeAt(i + 1) === codeDot && text.charCodeAt(i + 2) === codeDot) {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3;\n      parseWhitespaceAndSkipComments();\n      skipCharacter(codeComma);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      output += '{';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in {, message: \"hi\"}\n      if (skipCharacter(codeComma)) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        let processedComma;\n        if (!initial) {\n          processedComma = parseCharacter(codeComma);\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n          parseWhitespaceAndSkipComments();\n        } else {\n          processedComma = true;\n          initial = false;\n        }\n        skipEllipsis();\n        const processedKey = parseString() || parseUnquotedString();\n        if (!processedKey) {\n          if (text.charCodeAt(i) === codeClosingBrace || text.charCodeAt(i) === codeOpeningBrace || text.charCodeAt(i) === codeClosingBracket || text.charCodeAt(i) === codeOpeningBracket || text[i] === undefined) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',');\n          } else {\n            throwObjectKeyExpected();\n          }\n          break;\n        }\n        parseWhitespaceAndSkipComments();\n        const processedColon = parseCharacter(codeColon);\n        const truncatedText = i >= text.length;\n        if (!processedColon) {\n          if (isStartOfValue(text[i]) || truncatedText) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':');\n          } else {\n            throwColonExpected();\n          }\n        }\n        const processedValue = parseValue();\n        if (!processedValue) {\n          if (processedColon || truncatedText) {\n            // repair missing object value\n            output += 'null';\n          } else {\n            throwColonExpected();\n          }\n        }\n      }\n      if (text.charCodeAt(i) === codeClosingBrace) {\n        output += '}';\n        i++;\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      output += '[';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in [,1,2,3]\n      if (skipCharacter(codeComma)) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          const processedComma = parseCharacter(codeComma);\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n        } else {\n          initial = false;\n        }\n        skipEllipsis();\n        const processedValue = parseValue();\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',');\n          break;\n        }\n      }\n      if (text.charCodeAt(i) === codeClosingBracket) {\n        output += ']';\n        i++;\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true;\n    let processedValue = true;\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(codeComma);\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',');\n        }\n      } else {\n        initial = false;\n      }\n      processedValue = parseValue();\n    }\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',');\n    }\n\n    // repair: wrap the output inside array brackets\n    output = \"[\\n\".concat(output, \"\\n]\");\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there.\n   */\n  function parseString() {\n    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let skipEscapeChars = text.charCodeAt(i) === codeBackslash;\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++;\n      skipEscapeChars = true;\n    }\n    if (isQuote(text.charCodeAt(i))) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(text.charCodeAt(i)) ? isDoubleQuote : isSingleQuote(text.charCodeAt(i)) ? isSingleQuote : isSingleQuoteLike(text.charCodeAt(i)) ? isSingleQuoteLike : isDoubleQuoteLike;\n      const iBefore = i;\n      const oBefore = output.length;\n      let str = '\"';\n      i++;\n      while (true) {\n        if (i >= text.length) {\n          // end of text, we are missing an end quote\n\n          const iPrev = prevNonWhitespaceIndex(i - 1);\n          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          return true;\n        } else if (isEndQuote(text.charCodeAt(i))) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i;\n          const oQuote = str.length;\n          str += '\"';\n          i++;\n          output += str;\n          parseWhitespaceAndSkipComments();\n          if (stopAtDelimiter || i >= text.length || isDelimiter(text.charAt(i)) || isQuote(text.charCodeAt(i)) || isDigit(text.charCodeAt(i))) {\n            // The quote is followed by the end of the text, a delimiter, or a next value\n            // so the quote is indeed the end of the string\n            parseConcatenatedString();\n            return true;\n          }\n          if (isDelimiter(text.charAt(prevNonWhitespaceIndex(iQuote - 1)))) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output = output.substring(0, oBefore);\n          i = iQuote + 1;\n\n          // repair unescaped quote\n          str = str.substring(0, oQuote) + '\\\\' + str.substring(oQuote);\n        } else if (stopAtDelimiter && isDelimiter(text[i])) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          parseConcatenatedString();\n          return true;\n        } else if (text.charCodeAt(i) === codeBackslash) {\n          // handle escaped content like \\n or \\u2605\n          const char = text.charAt(i + 1);\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            str += text.slice(i, i + 2);\n            i += 2;\n          } else if (char === 'u') {\n            let j = 2;\n            while (j < 6 && isHex(text.charCodeAt(i + j))) {\n              j++;\n            }\n            if (j === 6) {\n              str += text.slice(i, i + 6);\n              i += 6;\n            } else if (i + j >= text.length) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i = text.length;\n            } else {\n              throwInvalidUnicodeCharacter();\n            }\n          } else {\n            // repair invalid escape character: remove it\n            str += char;\n            i += 2;\n          }\n        } else {\n          // handle regular characters\n          const char = text.charAt(i);\n          const code = text.charCodeAt(i);\n          if (code === codeDoubleQuote && text.charCodeAt(i - 1) !== codeBackslash) {\n            // repair unescaped double quote\n            str += '\\\\' + char;\n            i++;\n          } else if (isControlCharacter(code)) {\n            // unescaped control character\n            str += controlCharacters[char];\n            i++;\n          } else {\n            if (!isValidStringCharacter(code)) {\n              throwInvalidCharacter(char);\n            }\n            str += char;\n            i++;\n          }\n        }\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter();\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString() {\n    let processed = false;\n    parseWhitespaceAndSkipComments();\n    while (text.charCodeAt(i) === codePlus) {\n      processed = true;\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true);\n      const start = output.length;\n      const parsedStr = parseString();\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output = removeAtIndex(output, start, 1);\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output = insertBeforeLastWhitespace(output, '\"');\n      }\n    }\n    return processed;\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber() {\n    const start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start;\n        return false;\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(text.charCodeAt(i))) {\n      i++;\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text.charCodeAt(i))) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start;\n      return false;\n    }\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = text.slice(start, i);\n      const hasInvalidLeadingZero = /^0\\d/.test(num);\n      output += hasInvalidLeadingZero ? \"\\\"\".concat(num, \"\\\"\") : num;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords() {\n    return parseKeyword('true', 'true') || parseKeyword('false', 'false') || parseKeyword('null', 'null') ||\n    // repair Python keywords True, False, None\n    parseKeyword('True', 'true') || parseKeyword('False', 'false') || parseKeyword('None', 'null');\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      output += value;\n      i += name.length;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Repair an unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString() {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    const start = i;\n    while (i < text.length && !isDelimiterExceptSlash(text[i]) && !isQuote(text.charCodeAt(i))) {\n      i++;\n    }\n    if (i > start) {\n      if (text.charCodeAt(i) === codeOpenParenthesis && isFunctionName(text.slice(start, i).trim())) {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i++;\n        parseValue();\n        if (text.charCodeAt(i) === codeCloseParenthesis) {\n          // repair: skip close bracket of function call\n          i++;\n          if (text.charCodeAt(i) === codeSemicolon) {\n            // repair: skip semicolon after JSONP call\n            i++;\n          }\n        }\n        return true;\n      } else {\n        // repair unquoted string\n        // also, repair undefined into null\n\n        // first, go back to prevent getting trailing whitespaces in the string\n        while (isWhitespace(text.charCodeAt(i - 1)) && i > 0) {\n          i--;\n        }\n        const symbol = text.slice(start, i);\n        output += symbol === 'undefined' ? 'null' : JSON.stringify(symbol);\n        if (text.charCodeAt(i) === codeDoubleQuote) {\n          // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n          i++;\n        }\n        return true;\n      }\n    }\n  }\n  function prevNonWhitespaceIndex(start) {\n    let prev = start;\n    while (prev > 0 && isWhitespace(text.charCodeAt(prev))) {\n      prev--;\n    }\n    return prev;\n  }\n  function atEndOfNumber() {\n    return i >= text.length || isDelimiter(text[i]) || isWhitespace(text.charCodeAt(i));\n  }\n  function repairNumberEndingWithNumericSymbol(start) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output += text.slice(start, i) + '0';\n  }\n  function throwInvalidCharacter(char) {\n    throw new JSONRepairError('Invalid character ' + JSON.stringify(char), i);\n  }\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError('Unexpected character ' + JSON.stringify(text[i]), i);\n  }\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length);\n  }\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i);\n  }\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i);\n  }\n  function throwInvalidUnicodeCharacter() {\n    const chars = text.slice(i, i + 6);\n    throw new JSONRepairError(\"Invalid unicode character \\\"\".concat(chars, \"\\\"\"), i);\n  }\n}\nfunction atEndOfBlockComment(text, i) {\n  return text[i] === '*' && text[i + 1] === '/';\n}\n//# sourceMappingURL=jsonrepair.js.map"],"names":["JSONRepairError","Error","constructor","message","position","super","this","codeBackslash","codeSlash","codeAsterisk","codeOpeningBrace","codeClosingBrace","codeOpeningBracket","codeClosingBracket","codeOpenParenthesis","codeCloseParenthesis","codeSpace","codeNewline","codeTab","codeReturn","codeBackspace","codeFormFeed","codeDoubleQuote","codePlus","codeMinus","codeQuote","codeZero","codeNine","codeComma","codeDot","codeColon","codeSemicolon","codeUppercaseA","codeLowercaseA","codeUppercaseE","codeLowercaseE","codeUppercaseF","codeLowercaseF","codeNonBreakingSpace","codeEnQuad","codeHairSpace","codeNarrowNoBreakSpace","codeMediumMathematicalSpace","codeIdeographicSpace","codeDoubleQuoteLeft","codeDoubleQuoteRight","codeQuoteLeft","codeQuoteRight","codeGraveAccent","codeAcuteAccent","isDigit","code","isValidStringCharacter","isDelimiter","char","regexDelimiter","test","isStartOfValue","regexStartOfValue","isQuote","charCodeAt","isControlCharacter","isWhitespace","isDoubleQuoteLike","isSingleQuoteLike","isDoubleQuote","isSingleQuote","stripLastOccurrence","text","textToStrip","stripRemainingText","arguments","length","undefined","index","lastIndexOf","substring","insertBeforeLastWhitespace","textToInsert","removeAtIndex","start","count","controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepair","i","output","parseValue","throwUnexpectedEnd","processedComma","parseCharacter","parseWhitespaceAndSkipComments","endsWithCommaOrNewline","initial","processedValue","concat","parseNewlineDelimitedJSON","processed","skipCharacter","skipEllipsis","parseString","parseUnquotedString","throwObjectKeyExpected","processedColon","truncatedText","throwColonExpected","parseObject","parseArray","atEndOfNumber","repairNumberEndingWithNumericSymbol","num","slice","hasInvalidLeadingZero","parseNumber","parseKeyword","changed","parseWhitespace","parseComment","normal","whitespace","atEndOfBlockComment","stopAtDelimiter","skipEscapeChars","isEndQuote","iBefore","oBefore","str","iPrev","prevNonWhitespaceIndex","charAt","iQuote","oQuote","parseConcatenatedString","j","throwInvalidUnicodeCharacter","throwInvalidCharacter","parsedStr","name","value","isFunctionName","trim","symbol","JSON","stringify","prev","chars","throwUnexpectedCharacter"],"sourceRoot":""}